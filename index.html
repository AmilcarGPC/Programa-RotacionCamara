<html><head></head><body>
      <canvas width="570" height="570" id="my_Canvas" style="display: block; margin: 0 auto;"></canvas>
      
      <div style="margin-top: 10px; text-align: center;">
         <h3>Controles de Cámara</h3>
         <p>Usa las teclas WASD o las flechas del teclado para mover la cámara:</p>
         <p>W/↑: Subir cámara | S/↓: Bajar cámara | A/←: Izquierda | D/→: Derecha</p>
         <p><strong>G: Activar/Desactivar Malla de ejes</strong></p>
         <div style="margin-top: 10px;">
            <button id="upBtn" style="display: block; margin: 5px auto;">↑ Subir (W)</button>
            <div>
               <button id="leftBtn" style="margin: 5px;">← Izquierda (A)</button>
               <button id="downBtn" style="margin: 5px;">↓ Bajar (S)</button>
               <button id="rightBtn" style="margin: 5px;">→ Derecha (D)</button>
            </div>
            <div style="margin-top: 15px;">
               <button id="toggleGridBtn" style="padding: 10px; font-weight: bold; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">🔲 Activar Malla (G)</button>
            </div>
         </div>
      </div>
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
<script import="" {vec3,="" mat4}="" from="" src="https://webgpufundamentals.org/3rdparty/wgpu-matrix.module.js" ;="">
</script>
      <script>
         main();
         function main(){
            var canvas = document.getElementById('my_Canvas');
            gl = canvas.getContext('experimental-webgl');
            if(gl == null){
               alert("Error. Aborting.....");
               return;
            }
            //cilindro
            var sides = 10;
            var height = 0.001;
            var stepTheta = 2 * Math.PI / sides;
            var verticesPerCap = 9 * sides;

            var verticesCyl = [];
            var colorsCyl = [];
            var theta = 0;
            var i = 0;

            var scale = 0.5;

            // Top Cap
            color_random_r = Math.random()
            color_random_g = Math.random()
            color_random_b = Math.random()

            for (; i < verticesPerCap; i += 9) {
               verticesCyl[i    ] = scale*Math.cos(theta); colorsCyl[i]=color_random_b;
               verticesCyl[i + 1] = height;          colorsCyl[i+1]=color_random_r;
               verticesCyl[i + 2] = scale*Math.sin(theta); colorsCyl[i+2]=color_random_g;
               theta += stepTheta;

               verticesCyl[i + 3] = 0.0;             colorsCyl[i+3]=color_random_b;
               verticesCyl[i + 4] = height;          colorsCyl[i+4]=color_random_r;
               verticesCyl[i + 5] = 0.0;             colorsCyl[i+5]=color_random_g;

               verticesCyl[i + 6] = scale*Math.cos(theta); colorsCyl[i+6]=color_random_b;
               verticesCyl[i + 7] = height;          colorsCyl[i+7]=color_random_r;
               verticesCyl[i + 8] = scale*Math.sin(theta); colorsCyl[i+8]=color_random_g;
            }

            // Bottom Cap
            theta = 0;
            for (; i < verticesPerCap + verticesPerCap; i += 9) {
               verticesCyl[i + 6] = scale*Math.cos(theta); 
               verticesCyl[i + 7] = -height;
               verticesCyl[i + 8] = scale*Math.sin(theta);
               theta += stepTheta;

               verticesCyl[i + 3] = 0.0;
               verticesCyl[i + 4] = -height;
               verticesCyl[i + 5] = 0.0;

               verticesCyl[i    ] = scale*Math.cos(theta);
               verticesCyl[i + 1] = -height;
               verticesCyl[i + 2] = scale*Math.sin(theta);
            }

            for (var j = 0; j < sides; ++j) {
               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[0 + k + 9 * j];
               }
               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[6 + k + 9 * j];
               }
               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[verticesPerCap + k + 9 * j];
               }

               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[0 + k + 9 * j];
               }
               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[verticesPerCap + k + 9 * j];
               }
               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[verticesPerCap + 6 + k + 9 * j];
               }
            }

            var indicesCyl = new Array(verticesCyl.length / 3);
            for (i = 0; i < indicesCyl.length; ++i) indicesCyl[i] = i;
         //===================

         //=================== Malla de ejes
            var gridSize = 5;
            var gridStep = 1;
            var gridOpacity = 0.3;
            var gridEnabled = false;
            var currentGridOpacity = 0.0;

            var verticesGrid = [];
            var colorsGrid = [];
            var indicesGrid = [];
            var gridIndex = 0;

            // Líneas paralelas al eje X
            for (var y = -gridSize; y <= gridSize; y += gridStep) {
                for (var z = -gridSize; z <= gridSize; z += gridStep) {
                    verticesGrid.push(-gridSize, y, z);
                    verticesGrid.push(gridSize, y, z);
                    
                    colorsGrid.push(1.0, 0.2, 0.2, currentGridOpacity);
                    colorsGrid.push(1.0, 0.2, 0.2, currentGridOpacity);
                    
                    indicesGrid.push(gridIndex, gridIndex + 1);
                    gridIndex += 2;
                }
            }

            // Líneas paralelas al eje Y
            for (var x = -gridSize; x <= gridSize; x += gridStep) {
                for (var z = -gridSize; z <= gridSize; z += gridStep) {
                    verticesGrid.push(x, -gridSize, z);
                    verticesGrid.push(x, gridSize, z);
                    
                    colorsGrid.push(0.2, 1.0, 0.2, currentGridOpacity);
                    colorsGrid.push(0.2, 1.0, 0.2, currentGridOpacity);
                    
                    indicesGrid.push(gridIndex, gridIndex + 1);
                    gridIndex += 2;
                }
            }

            // Líneas paralelas al eje Z
            for (var x = -gridSize; x <= gridSize; x += gridStep) {
                for (var y = -gridSize; y <= gridSize; y += gridStep) {
                    verticesGrid.push(x, y, -gridSize);
                    verticesGrid.push(x, y, gridSize);
                    
                    colorsGrid.push(0.2, 0.2, 1.0, currentGridOpacity);
                    colorsGrid.push(0.2, 0.2, 1.0, currentGridOpacity);
                    
                    indicesGrid.push(gridIndex, gridIndex + 1);
                    gridIndex += 2;
                }
            }
         //===================

         // for (let i = 0; i < numObjects; ++i) {
         //    const across = Math.sqrt(numObjects) | 0;
         //    const x = (i % across - (across - 1) / 2) * 3;
         //    const y = ((i / across | 0) - (across - 1) / 2) * 3;

         //    objectInfos.push({
         //       translation: [x, y, 0],
         //    });
         //}

         //===================
            var vertex_bufferCyl = gl.createBuffer ();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferCyl);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesCyl), gl.STATIC_DRAW);
            //
            var color_bufferCyl = gl.createBuffer ();
            gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferCyl);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorsCyl), gl.STATIC_DRAW);
            //
            var index_bufferCyl = gl.createBuffer ();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_bufferCyl);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indicesCyl), gl.STATIC_DRAW);
            
            //================= 
            var vertex_bufferGrid = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferGrid);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesGrid), gl.STATIC_DRAW);
            //
            var color_bufferGrid = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferGrid);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorsGrid), gl.STATIC_DRAW);
            //
            var index_bufferGrid = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_bufferGrid);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indicesGrid), gl.STATIC_DRAW);
            //=================
            //
            var vertCode = 'attribute vec3 position;'+
               'uniform mat4 Pmatrix;'+
               'uniform mat4 Vmatrix;'+
               'uniform mat4 Mmatrix;'+
               'attribute vec4 color;'+
               'varying vec4 vColor;'+

               'void main(void) { '+
                  'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
                  'vColor = color;'+
               '}';
            var fragCode = 'precision mediump float;'+
               'varying vec4 vColor;'+
               'void main(void) {'+
                  'gl_FragColor = vColor;'+
               '}';
            var vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertCode);
            gl.compileShader(vertShader);
            var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragCode);
            gl.compileShader(fragShader);
            var shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertShader);
            gl.attachShader(shaderProgram, fragShader);
            gl.linkProgram(shaderProgram);
            //matrices Cylinder
            var PmatrixCyl = gl.getUniformLocation(shaderProgram, "Pmatrix");
            var VmatrixCyl = gl.getUniformLocation(shaderProgram, "Vmatrix");
            var MmatrixCyl = gl.getUniformLocation(shaderProgram, "Mmatrix");
            var proj_matrixCyl = get_projection(40, canvas.width/canvas.height, 1, 100);
            var mov_matrixCyl = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            var view_matrixCyl = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            view_matrixCyl[14] = view_matrixCyl[14]-5
            //buffers
            var positionCyl;
            var colorCyl;
            
            //================Cylinder
            //buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferCyl);
            positionCyl = gl.getAttribLocation(shaderProgram, "position");
            gl.vertexAttribPointer(positionCyl, 3, gl.FLOAT, false,0,0) ;
            gl.enableVertexAttribArray(positionCyl);
            gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferCyl);
            colorCyl = gl.getAttribLocation(shaderProgram, "color");
            gl.vertexAttribPointer(colorCyl, 3, gl.FLOAT, false,0,0) ;
            gl.enableVertexAttribArray(colorCyl);
            gl.useProgram(shaderProgram);
            //animation

            // ============================================
            // ***            CÓDIGO EDITADO            ***
            // ============================================
            var time_old = 0;
            var mov_matrixCyl = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            rotateX(mov_matrixCyl, Math.PI/2);

            // Inicializar los ángulos a 0
            var ax = 0;
            var ay = 0;

            // Variables para controlar la rotación de la cámara
            var cameraRotX = 0;
            var cameraRotY = 0;
            var rotationStep = 0.05;

            // Configurar controles de teclado y botones
            var keys = {};
            
            // Event listeners para teclado
            document.addEventListener('keydown', function(e) {
                keys[e.key.toLowerCase()] = true;
                keys[e.code] = true;
            });
            
            document.addEventListener('keyup', function(e) {
                keys[e.key.toLowerCase()] = false;
                keys[e.code] = false;
            });

            // Event listeners para botones
            document.getElementById('upBtn').addEventListener('click', function() {
                cameraRotX -= rotationStep;
            });
            document.getElementById('downBtn').addEventListener('click', function() {
                cameraRotX += rotationStep;
            });
            document.getElementById('leftBtn').addEventListener('click', function() {
                cameraRotY -= rotationStep;
            });
            document.getElementById('rightBtn').addEventListener('click', function() {
                cameraRotY += rotationStep;
            });

            // Event listener para el botón de activar/desactivar malla
            document.getElementById('toggleGridBtn').addEventListener('click', function() {
                toggleGrid();
            });

            // Función para alternar la visibilidad de la malla
            function toggleGrid() {
                gridEnabled = !gridEnabled;
                var button = document.getElementById('toggleGridBtn');
                
                if (gridEnabled) {
                    currentGridOpacity = gridOpacity;
                    button.textContent = '🔳 Desactivar Malla (G)';
                    button.style.backgroundColor = '#f44336';
                } else {
                    currentGridOpacity = 0.0;
                    button.textContent = '🔲 Activar Malla (G)';
                    button.style.backgroundColor = '#4CAF50';
                }
                
                // Actualizar los colores de la malla
                updateGridColors();
            }

            // Función para actualizar los colores de la malla
            function updateGridColors() {
                var newColorsGrid = [];
                var colorIndex = 0;
                
                // Actualizar colores para líneas del eje X (rojas)
                for (var y = -gridSize; y <= gridSize; y += gridStep) {
                    for (var z = -gridSize; z <= gridSize; z += gridStep) {
                        newColorsGrid.push(1.0, 0.2, 0.2, currentGridOpacity);
                        newColorsGrid.push(1.0, 0.2, 0.2, currentGridOpacity);
                    }
                }
                
                // Actualizar colores para líneas del eje Y (verdes)
                for (var x = -gridSize; x <= gridSize; x += gridStep) {
                    for (var z = -gridSize; z <= gridSize; z += gridStep) {
                        newColorsGrid.push(0.2, 1.0, 0.2, currentGridOpacity);
                        newColorsGrid.push(0.2, 1.0, 0.2, currentGridOpacity);
                    }
                }
                
                // Actualizar colores para líneas del eje Z (azules)
                for (var x = -gridSize; x <= gridSize; x += gridStep) {
                    for (var y = -gridSize; y <= gridSize; y += gridStep) {
                        newColorsGrid.push(0.2, 0.2, 1.0, currentGridOpacity);
                        newColorsGrid.push(0.2, 0.2, 1.0, currentGridOpacity);
                    }
                }
                
                // Actualizar el buffer de colores
                gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferGrid);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(newColorsGrid), gl.STATIC_DRAW);
            }

            // Dirección a favor o en contra del reloj
            var dir = (-1)**(Math.floor(Math.random()*2))
            var animate = function(time) {
               
               gl.enable(gl.DEPTH_TEST);
               gl.depthFunc(gl.LEQUAL);
               gl.enable(gl.BLEND);
               gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
               gl.clearColor(0.5, 0.5, 0.5, 0.9);
               gl.clearDepth(1.0);
               gl.viewport(0.0, 0.0, canvas.width, canvas.height);
               gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

               // Procesar controles de teclado
               if (keys['w'] || keys['ArrowUp']) {
                   cameraRotX -= 0.01;
               }
               if (keys['s'] || keys['ArrowDown']) {
                   cameraRotX += 0.01;
               }
               if (keys['a'] || keys['ArrowLeft']) {
                   cameraRotY -= 0.01;
               }
               if (keys['d'] || keys['ArrowRight']) {
                   cameraRotY += 0.01;
               }
               
               // Control para activar/desactivar malla con tecla G
               if (keys['g'] || keys['G']) {
                   if (!keys.gPressed) {
                       toggleGrid();
                       keys.gPressed = true;
                   }
               } else {
                   keys.gPressed = false;
               }

               // Operaciones de rotación de cámara
               view_matrixCyl = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-5,1];
               rotateX(view_matrixCyl, cameraRotX);
               rotateY(view_matrixCyl, cameraRotY);

               // Operaciones de rotación y traslación del cilindro
               var dt = time-time_old;
               rotateZ(mov_matrixCyl, -1*dir*dt*0.005);
               trasladaX(mov_matrixCyl, 3*Math.cos(ax*0.008)) // Alrededor de un punto (eje x)
               trasladaY(mov_matrixCyl, 3*Math.sin(ay*0.008)) // Alrededor de un punto (eje y)

               ax += 1*dir;
               ay += 1*dir;
               time_old = time;
               //================================== Cylinder
               gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferCyl);
               positionCyl = gl.getAttribLocation(shaderProgram, "position");
               gl.vertexAttribPointer(positionCyl, 3, gl.FLOAT, false,0,0) ;
               gl.enableVertexAttribArray(positionCyl);
               gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferCyl);
               colorCyl = gl.getAttribLocation(shaderProgram, "color");
               gl.vertexAttribPointer(colorCyl, 3, gl.FLOAT, false,0,0) ;
               gl.enableVertexAttribArray(colorCyl);
               gl.useProgram(shaderProgram);

               gl.uniformMatrix4fv(PmatrixCyl, false, proj_matrixCyl);
               gl.uniformMatrix4fv(VmatrixCyl, false, view_matrixCyl);
               gl.uniformMatrix4fv(MmatrixCyl, false, mov_matrixCyl);
               gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_bufferCyl);
               gl.drawElements(gl.TRIANGLES, indicesCyl.length, gl.UNSIGNED_SHORT, 0);
               //================================== Cylinder

               //================================== Malla de ejes
               var identity_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
               gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferGrid);
               var positionGrid = gl.getAttribLocation(shaderProgram, "position");
               gl.vertexAttribPointer(positionGrid, 3, gl.FLOAT, false,0,0);
               gl.enableVertexAttribArray(positionGrid);
               gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferGrid);
               var colorGrid = gl.getAttribLocation(shaderProgram, "color");
               gl.vertexAttribPointer(colorGrid, 4, gl.FLOAT, false,0,0);
               gl.enableVertexAttribArray(colorGrid);
               gl.useProgram(shaderProgram);

               gl.uniformMatrix4fv(PmatrixCyl, false, proj_matrixCyl);
               gl.uniformMatrix4fv(VmatrixCyl, false, view_matrixCyl);
               gl.uniformMatrix4fv(MmatrixCyl, false, identity_matrix);
               gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_bufferGrid);
               gl.drawElements(gl.LINES, indicesGrid.length, gl.UNSIGNED_SHORT, 0);
               //================================== Malla de ejes
               window.requestAnimationFrame(animate);
            }
            animate(0);
         }
         //======================================================
         function get_projection(angle, a, zMin, zMax) {
            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5
            return [
               0.5/ang, 0 , 0, 0,
               0, 0.5*a/ang, 0, 0,
               0, 0, -(zMax+zMin)/(zMax-zMin), -1,
               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0 
            ];
         }
         //======================================================
         function trasladaX(m, desplazaX) {
            //var c = Math.cos(adesplazaX);
            //var s = Math.sin(desplazaX);
            //var mv0 = m[0], mv4 = m[4], mv8 = m[8];
            //m[0]=m[0]+0;  m[1]=m[1]+0;  m[2]=m[2]+0; m[3]=m[3]+0;
            //m[4]=m[4]+0;  m[5]=m[5]+0;  m[6]=m[6]+0; m[7]=m[7]+0;
            //m[8]=m[8]+0;  m[9]=m[9]+0;  m[10]=m[10]+0; m[11]=m[11]+0;
            //m[12]=desplazaX+0; m[13]=m[13]+0; m[14]=m[14]+0; m[15]=m[15]+0;
            m[12]=desplazaX;
         }
         function trasladaY(m, desplazaY) {
            //var c = Math.cos(adesplazaX);
            //var s = Math.sin(desplazaX);
            //var mv0 = m[0], mv4 = m[4], mv8 = m[8];
            //m[0]=m[0]+0;  m[1]=m[1]+0;  m[2]=m[2]+0; m[3]=m[3]+0;
            //m[4]=m[4]+0;  m[5]=m[5]+0;  m[6]=m[6]+0; m[7]=m[7]+0;
            //m[8]=m[8]+0;  m[9]=m[9]+0;  m[10]=m[10]+0; m[11]=m[11]+0;
            //m[12]=desplazaX+0; m[13]=m[13]+0; m[14]=m[14]+0; m[15]=m[15]=0;
            m[13]=desplazaY;
         }
         //======================================================
         function rotateY(m, angle) {
            
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];

            m[0] = c*m[0]+s*m[2];
            m[4] = c*m[4]+s*m[6];
            m[8] = c*m[8]+s*m[10];

            m[2] = c*m[2]-s*mv0;
            m[6] = c*m[6]-s*mv4;
            m[10] = c*m[10]-s*mv8;
         }
         //======================================================
         function rotateX(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv1 = m[1], mv5 = m[5], mv9 = m[9];

            m[1] = m[1]*c-m[2]*s;
            m[5] = m[5]*c-m[6]*s;
            m[9] = m[9]*c-m[10]*s;

            m[2] = m[2]*c+mv1*s;
            m[6] = m[6]*c+mv5*s;
            m[10] = m[10]*c+mv9*s;
         }

         function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8]; 

            m[0] = c*m[0]-s*m[1];
            m[4] = c*m[4]-s*m[5];
            m[8] = c*m[8]-s*m[9];

            m[1] = c*m[1]+s*mv0;
            m[5] = c*m[5]+s*mv4;
            m[9] = c*m[9]+s*mv8;
         }
         //======================================================
         function updateMatrix() {

         }
         //======================================================
         function sub (a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; };
  function cross (a, b) {
    return [
      a[1] * b[2] - a[2] * b[1],
      a[2] * b[0] - a[0] * b[2],
      a[0] * b[1] - a[1] * b[0]
    ];
  };
  //======================================================
  function normalize (a) {
    var length = a[0] * a[0] + a[1] * a[1] + a[2] * a[2];
    return [a[0] / length, a[1] / length, a[2] / length];
  };
  //======================================================
  function createBuffer(gl, data, type = gl.ARRAY_BUFFER) {
    const buf = gl.createBuffer();
    gl.bindBuffer(type, buf);
    gl.bufferData(type, data, gl.STATIC_DRAW);
    return buf;
  }
//======================================================
      </script>
   
</body></html>